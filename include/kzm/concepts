#pragma once

#include <kzm/bits/concepts/convertible_to.h>
#include <kzm/bits/concepts/derived_from.h>
#include <kzm/bits/concepts/same_as.h>

// Concepts library

// 18.3 Header <concepts> synopsis[concepts.syn]

// namespace std {
//   // [concepts.lang], language-related concepts
//   // [concept.same], concept same_­as
//   template<class T, class U>
//     concept same_as = see below;

//   // [concept.derived], concept derived_­from
//   template<class Derived, class Base>
//     concept derived_from = see below;

//   // [concept.convertible], concept convertible_­to
//   template<class From, class To>
//     concept convertible_to = see below;

//   // [concept.commonref], concept common_­reference_­with
//   template<class T, class U>
//     concept common_reference_with = see below;

//   // [concept.common], concept common_­with
//   template<class T, class U>
//     concept common_with = see below;

//   // [concepts.arithmetic], arithmetic concepts
//   template<class T>
//     concept integral = see below;
//   template<class T>
//     concept signed_integral = see below;
//   template<class T>
//     concept unsigned_integral = see below;
//   template<class T>
//     concept floating_point = see below;

//   // [concept.assignable], concept assignable_­from
//   template<class LHS, class RHS>
//     concept assignable_from = see below;

//   // [concept.swappable], concept swappable
//   namespace ranges {
//     inline namespace unspecified {
//       inline constexpr unspecified swap = unspecified;
//     }
//   }
//   template<class T>
//     concept swappable = see below;
//   template<class T, class U>
//     concept swappable_with = see below;

//   // [concept.destructible], concept destructible
//   template<class T>
//     concept destructible = see below;

//   // [concept.constructible], concept constructible_­from
//   template<class T, class... Args>
//     concept constructible_from = see below;

//   // [concept.default.init], concept default_­initializable
//   template<class T>
//     concept default_initializable = see below;

//   // [concept.moveconstructible], concept move_­constructible
//   template<class T>
//     concept move_constructible = see below;

//   // [concept.copyconstructible], concept copy_­constructible
//   template<class T>
//     concept copy_constructible = see below;

//   // [concepts.compare], comparison concepts
//   // [concept.equalitycomparable], concept equality_­comparable
//   template<class T>
//     concept equality_comparable = see below;
//   template<class T, class U>
//     concept equality_comparable_with = see below;

//   // [concept.totallyordered], concept totally_­ordered
//   template<class T>
//     concept totally_ordered = see below;
//   template<class T, class U>
//     concept totally_ordered_with = see below;

//   // [concepts.object], object concepts
//   template<class T>
//     concept movable = see below;
//   template<class T>
//     concept copyable = see below;
//   template<class T>
//     concept semiregular = see below;
//   template<class T>
//     concept regular = see below;

//   // [concepts.callable], callable concepts
//   // [concept.invocable], concept invocable
//   template<class F, class... Args>
//     concept invocable = see below;

//   // [concept.regularinvocable], concept regular_­invocable
//   template<class F, class... Args>
//     concept regular_invocable = see below;

//   // [concept.predicate], concept predicate
//   template<class F, class... Args>
//     concept predicate = see below;

//   // [concept.relation], concept relation
//   template<class R, class T, class U>
//     concept relation = see below;

//   // [concept.equiv], concept equivalence_­relation
//   template<class R, class T, class U>
//     concept equivalence_relation = see below;

//   // [concept.strictweakorder], concept strict_­weak_­order
//   template<class R, class T, class U>
//     concept strict_weak_order = see below;
// }


